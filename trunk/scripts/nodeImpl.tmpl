#def getTargetFileName(): src/Boo/Ast/Impl/${item.name}Impl.cs
#def initializer()
	#for field in $item.fields
		#unless "lazy" in $field.attributes
			#if cs.isCollection($model.resolve($field.type))
			$cs.toPrivateName($field.name) = new ${field.type}(this);
			#end if
			#if "auto" in $field.attributes
			$field.name = new ${field.type}();
			#end if			
		#end unless
	#end for
#end def
#def constructorParameters(fields)
	#for field in $fields
$field.type $cs.toLocalName(field.name)#slurp
	#if $field != $fields[-1]
, #slurp
	#end if
	#end for
#end def
#raw
#region license
// boo - an extensible programming language for the CLI
// Copyright (C) 2004 Rodrigo B. de Oliveira
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//
// As a special exception, if you link this library with other files to
// produce an executable, this library does not by itself cause the
// resulting executable to be covered by the GNU General Public License.
// This exception does not however invalidate any other reasons why the
// executable file might be covered by the GNU General Public License.
//
// Contact Information
//
// mailto:rbo@acm.org
#endregion

#end raw
//
// DO NOT EDIT THIS FILE!
//
// This file was generated automatically by the
// ast.py script on ${time.asctime()}
//
using System;

namespace Boo.Ast.Impl
{
	[Serializable]
	public abstract class ${item.name}Impl : #echo ", ".join($item.baseTypes)
	{
		#for field in $item.fields		
		protected $field.type $cs.toPrivateName($field.name);
		#end for
		
		protected ${item.name}Impl()
		{
$initializer() #slurp
		}
		#set simpleFields=list(cs.getNonAutoFields($item.fields))
		#if $simpleFields
		
		protected ${item.name}Impl($constructorParameters($simpleFields))
		{
$initializer() #slurp
			#for field in $simpleFields
			$field.name = $cs.toLocalName($field.name);
				#if "LexicalInfo" in $field.attributes
			LexicalInfo = ${cs.toLocalName($field.name)}.LexicalInfo;
				#end if
			#end for
		}
		
		protected ${item.name}Impl(antlr.Token token, $constructorParameters($simpleFields)) : base(token)
		{
$initializer() #slurp
			#for field in $simpleFields
			$field.name = $cs.toLocalName($field.name);
				#if "LexicalInfo" in $field.attributes
			LexicalInfo = ${cs.toLocalName($field.name)}.LexicalInfo;
				#end if
			#end for
		}
		#end if
		
		internal ${item.name}Impl(antlr.Token token) : base(token)
		{
$initializer() #slurp
		}
		
		internal ${item.name}Impl(Node lexicalInfoProvider) : base(lexicalInfoProvider)
		{
$initializer() #slurp
		}
		
		#unless "abstract" in $item.attributes
		public override NodeType NodeType
		{
			get
			{
				return NodeType.${item.name};
			}
		}
		#end unless
		#for field in $item.fields
		#set fieldName=$cs.toPrivateName($field.name)
		#set fieldType=$model.resolve($field.type)
			#if "lazy" in $field.attributes
		[System.Xml.Serialization.XmlIgnore]
		public $field.type $field.name
		{
			get
			{
				if (null == $fieldName)
				{
					$fieldName = new ${field.type}(this);
				}
				return ${fieldName};
			}
		}
			#else
		public $field.type $field.name
		{
			get
			{
				return ${fieldName};
			}
			
			set
			{
				
				#if $fieldType
				if ($fieldName != value)
				{
					$fieldName = value;
					#if $fieldType.extends("Node") or "collection" == $fieldType.stereotype
					if (null != ${fieldName})
					{
						${fieldName}.InitializeParent(this);
					}
					#end if
					#if "LexicalInfo" in $field.attributes
					LexicalInfo = value.LexicalInfo;
					#end if
				}
				#else
				$fieldName = value;
				#end if				
			}
		}
			#end if
		#end for		
		#unless "abstract" in $item.attributes 
		public override void Switch(IAstTransformer transformer, out Node resultingNode)
		{
			${item.name} thisNode = (${item.name})this;
			$cs.getResultTransformerNode($item) resultingTypedNode = thisNode;
			transformer.On${item.name}(thisNode, ref resultingTypedNode);
			resultingNode = resultingTypedNode;
		}
		#end unless
	}
}
