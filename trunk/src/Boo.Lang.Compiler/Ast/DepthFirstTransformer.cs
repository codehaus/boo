#region license
// boo - an extensible programming language for the CLI
// Copyright (C) 2004 Rodrigo B. de Oliveira
//
// Permission is hereby granted, free of charge, to any person 
// obtaining a copy of this software and associated documentation 
// files (the "Software"), to deal in the Software without restriction, 
// including without limitation the rights to use, copy, modify, merge, 
// publish, distribute, sublicense, and/or sell copies of the Software, 
// and to permit persons to whom the Software is furnished to do so, 
// subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included 
// in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE 
// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// 
// Contact Information
//
// mailto:rbo@acm.org
#endregion

//
// DO NOT EDIT THIS FILE!
//
// This file was generated automatically by
// astgenerator.boo on 4/15/2004 1:23:03 AM
//

namespace Boo.Lang.Compiler.Ast
{
	using System;
	
	public class DepthFirstTransformer : IAstTransformer
	{
		public virtual void OnCompileUnit(Boo.Lang.Compiler.Ast.CompileUnit node, ref Boo.Lang.Compiler.Ast.CompileUnit resultingNode)
		{

			if (EnterCompileUnit(node, ref resultingNode))
			{

				Switch(node.Modules);

				LeaveCompileUnit(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterCompileUnit(Boo.Lang.Compiler.Ast.CompileUnit node, ref Boo.Lang.Compiler.Ast.CompileUnit resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveCompileUnit(Boo.Lang.Compiler.Ast.CompileUnit node, ref Boo.Lang.Compiler.Ast.CompileUnit resultingNode)
		{
		}

		public virtual void OnSimpleTypeReference(Boo.Lang.Compiler.Ast.SimpleTypeReference node, ref Boo.Lang.Compiler.Ast.TypeReference resultingNode)
		{

		}

		public virtual void OnTupleTypeReference(Boo.Lang.Compiler.Ast.TupleTypeReference node, ref Boo.Lang.Compiler.Ast.TypeReference resultingNode)
		{

			if (EnterTupleTypeReference(node, ref resultingNode))
			{

				TypeReference currentElementTypeValue = node.ElementType;
				if (null != currentElementTypeValue)
				{	
					Node resultingElementTypeValue;				
					currentElementTypeValue.Switch(this, out resultingElementTypeValue);					
					node.ElementType = resultingElementTypeValue as TypeReference;
				}

				LeaveTupleTypeReference(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterTupleTypeReference(Boo.Lang.Compiler.Ast.TupleTypeReference node, ref Boo.Lang.Compiler.Ast.TypeReference resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveTupleTypeReference(Boo.Lang.Compiler.Ast.TupleTypeReference node, ref Boo.Lang.Compiler.Ast.TypeReference resultingNode)
		{
		}

		public virtual void OnNamespaceDeclaration(Boo.Lang.Compiler.Ast.NamespaceDeclaration node, ref Boo.Lang.Compiler.Ast.NamespaceDeclaration resultingNode)
		{

		}

		public virtual void OnImport(Boo.Lang.Compiler.Ast.Import node, ref Boo.Lang.Compiler.Ast.Import resultingNode)
		{

			if (EnterImport(node, ref resultingNode))
			{

				ReferenceExpression currentAssemblyReferenceValue = node.AssemblyReference;
				if (null != currentAssemblyReferenceValue)
				{	
					Node resultingAssemblyReferenceValue;				
					currentAssemblyReferenceValue.Switch(this, out resultingAssemblyReferenceValue);					
					node.AssemblyReference = resultingAssemblyReferenceValue as ReferenceExpression;
				}

				ReferenceExpression currentAliasValue = node.Alias;
				if (null != currentAliasValue)
				{	
					Node resultingAliasValue;				
					currentAliasValue.Switch(this, out resultingAliasValue);					
					node.Alias = resultingAliasValue as ReferenceExpression;
				}

				LeaveImport(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterImport(Boo.Lang.Compiler.Ast.Import node, ref Boo.Lang.Compiler.Ast.Import resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveImport(Boo.Lang.Compiler.Ast.Import node, ref Boo.Lang.Compiler.Ast.Import resultingNode)
		{
		}

		public virtual void OnModule(Boo.Lang.Compiler.Ast.Module node, ref Boo.Lang.Compiler.Ast.Module resultingNode)
		{

			if (EnterModule(node, ref resultingNode))
			{

				Switch(node.Attributes);

				Switch(node.Members);

				Switch(node.BaseTypes);

				NamespaceDeclaration currentNamespaceValue = node.Namespace;
				if (null != currentNamespaceValue)
				{	
					Node resultingNamespaceValue;				
					currentNamespaceValue.Switch(this, out resultingNamespaceValue);					
					node.Namespace = resultingNamespaceValue as NamespaceDeclaration;
				}

				Switch(node.Imports);

				Block currentGlobalsValue = node.Globals;
				if (null != currentGlobalsValue)
				{	
					Node resultingGlobalsValue;				
					currentGlobalsValue.Switch(this, out resultingGlobalsValue);					
					node.Globals = resultingGlobalsValue as Block;
				}

				LeaveModule(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterModule(Boo.Lang.Compiler.Ast.Module node, ref Boo.Lang.Compiler.Ast.Module resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveModule(Boo.Lang.Compiler.Ast.Module node, ref Boo.Lang.Compiler.Ast.Module resultingNode)
		{
		}

		public virtual void OnClassDefinition(Boo.Lang.Compiler.Ast.ClassDefinition node, ref Boo.Lang.Compiler.Ast.ClassDefinition resultingNode)
		{

			if (EnterClassDefinition(node, ref resultingNode))
			{

				Switch(node.Attributes);

				Switch(node.Members);

				Switch(node.BaseTypes);

				LeaveClassDefinition(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterClassDefinition(Boo.Lang.Compiler.Ast.ClassDefinition node, ref Boo.Lang.Compiler.Ast.ClassDefinition resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveClassDefinition(Boo.Lang.Compiler.Ast.ClassDefinition node, ref Boo.Lang.Compiler.Ast.ClassDefinition resultingNode)
		{
		}

		public virtual void OnInterfaceDefinition(Boo.Lang.Compiler.Ast.InterfaceDefinition node, ref Boo.Lang.Compiler.Ast.InterfaceDefinition resultingNode)
		{

			if (EnterInterfaceDefinition(node, ref resultingNode))
			{

				Switch(node.Attributes);

				Switch(node.Members);

				Switch(node.BaseTypes);

				LeaveInterfaceDefinition(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterInterfaceDefinition(Boo.Lang.Compiler.Ast.InterfaceDefinition node, ref Boo.Lang.Compiler.Ast.InterfaceDefinition resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveInterfaceDefinition(Boo.Lang.Compiler.Ast.InterfaceDefinition node, ref Boo.Lang.Compiler.Ast.InterfaceDefinition resultingNode)
		{
		}

		public virtual void OnEnumDefinition(Boo.Lang.Compiler.Ast.EnumDefinition node, ref Boo.Lang.Compiler.Ast.EnumDefinition resultingNode)
		{

			if (EnterEnumDefinition(node, ref resultingNode))
			{

				Switch(node.Attributes);

				Switch(node.Members);

				Switch(node.BaseTypes);

				LeaveEnumDefinition(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterEnumDefinition(Boo.Lang.Compiler.Ast.EnumDefinition node, ref Boo.Lang.Compiler.Ast.EnumDefinition resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveEnumDefinition(Boo.Lang.Compiler.Ast.EnumDefinition node, ref Boo.Lang.Compiler.Ast.EnumDefinition resultingNode)
		{
		}

		public virtual void OnEnumMember(Boo.Lang.Compiler.Ast.EnumMember node, ref Boo.Lang.Compiler.Ast.EnumMember resultingNode)
		{

			if (EnterEnumMember(node, ref resultingNode))
			{

				Switch(node.Attributes);

				IntegerLiteralExpression currentInitializerValue = node.Initializer;
				if (null != currentInitializerValue)
				{	
					Node resultingInitializerValue;				
					currentInitializerValue.Switch(this, out resultingInitializerValue);					
					node.Initializer = resultingInitializerValue as IntegerLiteralExpression;
				}

				LeaveEnumMember(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterEnumMember(Boo.Lang.Compiler.Ast.EnumMember node, ref Boo.Lang.Compiler.Ast.EnumMember resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveEnumMember(Boo.Lang.Compiler.Ast.EnumMember node, ref Boo.Lang.Compiler.Ast.EnumMember resultingNode)
		{
		}

		public virtual void OnField(Boo.Lang.Compiler.Ast.Field node, ref Boo.Lang.Compiler.Ast.Field resultingNode)
		{

			if (EnterField(node, ref resultingNode))
			{

				Switch(node.Attributes);

				TypeReference currentTypeValue = node.Type;
				if (null != currentTypeValue)
				{	
					Node resultingTypeValue;				
					currentTypeValue.Switch(this, out resultingTypeValue);					
					node.Type = resultingTypeValue as TypeReference;
				}

				Expression currentInitializerValue = node.Initializer;
				if (null != currentInitializerValue)
				{	
					Node resultingInitializerValue;				
					currentInitializerValue.Switch(this, out resultingInitializerValue);					
					node.Initializer = resultingInitializerValue as Expression;
				}

				LeaveField(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterField(Boo.Lang.Compiler.Ast.Field node, ref Boo.Lang.Compiler.Ast.Field resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveField(Boo.Lang.Compiler.Ast.Field node, ref Boo.Lang.Compiler.Ast.Field resultingNode)
		{
		}

		public virtual void OnProperty(Boo.Lang.Compiler.Ast.Property node, ref Boo.Lang.Compiler.Ast.Property resultingNode)
		{

			if (EnterProperty(node, ref resultingNode))
			{

				Switch(node.Attributes);

				Switch(node.Parameters);

				Method currentGetterValue = node.Getter;
				if (null != currentGetterValue)
				{	
					Node resultingGetterValue;				
					currentGetterValue.Switch(this, out resultingGetterValue);					
					node.Getter = resultingGetterValue as Method;
				}

				Method currentSetterValue = node.Setter;
				if (null != currentSetterValue)
				{	
					Node resultingSetterValue;				
					currentSetterValue.Switch(this, out resultingSetterValue);					
					node.Setter = resultingSetterValue as Method;
				}

				TypeReference currentTypeValue = node.Type;
				if (null != currentTypeValue)
				{	
					Node resultingTypeValue;				
					currentTypeValue.Switch(this, out resultingTypeValue);					
					node.Type = resultingTypeValue as TypeReference;
				}

				LeaveProperty(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterProperty(Boo.Lang.Compiler.Ast.Property node, ref Boo.Lang.Compiler.Ast.Property resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveProperty(Boo.Lang.Compiler.Ast.Property node, ref Boo.Lang.Compiler.Ast.Property resultingNode)
		{
		}

		public virtual void OnLocal(Boo.Lang.Compiler.Ast.Local node, ref Boo.Lang.Compiler.Ast.Local resultingNode)
		{

		}

		public virtual void OnMethod(Boo.Lang.Compiler.Ast.Method node, ref Boo.Lang.Compiler.Ast.Method resultingNode)
		{

			if (EnterMethod(node, ref resultingNode))
			{

				Switch(node.Attributes);

				Switch(node.Parameters);

				TypeReference currentReturnTypeValue = node.ReturnType;
				if (null != currentReturnTypeValue)
				{	
					Node resultingReturnTypeValue;				
					currentReturnTypeValue.Switch(this, out resultingReturnTypeValue);					
					node.ReturnType = resultingReturnTypeValue as TypeReference;
				}

				Switch(node.ReturnTypeAttributes);

				Block currentBodyValue = node.Body;
				if (null != currentBodyValue)
				{	
					Node resultingBodyValue;				
					currentBodyValue.Switch(this, out resultingBodyValue);					
					node.Body = resultingBodyValue as Block;
				}

				Switch(node.Locals);

				LeaveMethod(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterMethod(Boo.Lang.Compiler.Ast.Method node, ref Boo.Lang.Compiler.Ast.Method resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveMethod(Boo.Lang.Compiler.Ast.Method node, ref Boo.Lang.Compiler.Ast.Method resultingNode)
		{
		}

		public virtual void OnConstructor(Boo.Lang.Compiler.Ast.Constructor node, ref Boo.Lang.Compiler.Ast.Constructor resultingNode)
		{

			if (EnterConstructor(node, ref resultingNode))
			{

				Switch(node.Attributes);

				Switch(node.Parameters);

				TypeReference currentReturnTypeValue = node.ReturnType;
				if (null != currentReturnTypeValue)
				{	
					Node resultingReturnTypeValue;				
					currentReturnTypeValue.Switch(this, out resultingReturnTypeValue);					
					node.ReturnType = resultingReturnTypeValue as TypeReference;
				}

				Switch(node.ReturnTypeAttributes);

				Block currentBodyValue = node.Body;
				if (null != currentBodyValue)
				{	
					Node resultingBodyValue;				
					currentBodyValue.Switch(this, out resultingBodyValue);					
					node.Body = resultingBodyValue as Block;
				}

				Switch(node.Locals);

				LeaveConstructor(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterConstructor(Boo.Lang.Compiler.Ast.Constructor node, ref Boo.Lang.Compiler.Ast.Constructor resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveConstructor(Boo.Lang.Compiler.Ast.Constructor node, ref Boo.Lang.Compiler.Ast.Constructor resultingNode)
		{
		}

		public virtual void OnParameterDeclaration(Boo.Lang.Compiler.Ast.ParameterDeclaration node, ref Boo.Lang.Compiler.Ast.ParameterDeclaration resultingNode)
		{

			if (EnterParameterDeclaration(node, ref resultingNode))
			{

				TypeReference currentTypeValue = node.Type;
				if (null != currentTypeValue)
				{	
					Node resultingTypeValue;				
					currentTypeValue.Switch(this, out resultingTypeValue);					
					node.Type = resultingTypeValue as TypeReference;
				}

				Switch(node.Attributes);

				LeaveParameterDeclaration(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterParameterDeclaration(Boo.Lang.Compiler.Ast.ParameterDeclaration node, ref Boo.Lang.Compiler.Ast.ParameterDeclaration resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveParameterDeclaration(Boo.Lang.Compiler.Ast.ParameterDeclaration node, ref Boo.Lang.Compiler.Ast.ParameterDeclaration resultingNode)
		{
		}

		public virtual void OnDeclaration(Boo.Lang.Compiler.Ast.Declaration node, ref Boo.Lang.Compiler.Ast.Declaration resultingNode)
		{

			if (EnterDeclaration(node, ref resultingNode))
			{

				TypeReference currentTypeValue = node.Type;
				if (null != currentTypeValue)
				{	
					Node resultingTypeValue;				
					currentTypeValue.Switch(this, out resultingTypeValue);					
					node.Type = resultingTypeValue as TypeReference;
				}

				LeaveDeclaration(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterDeclaration(Boo.Lang.Compiler.Ast.Declaration node, ref Boo.Lang.Compiler.Ast.Declaration resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveDeclaration(Boo.Lang.Compiler.Ast.Declaration node, ref Boo.Lang.Compiler.Ast.Declaration resultingNode)
		{
		}

		public virtual void OnAttribute(Boo.Lang.Compiler.Ast.Attribute node, ref Boo.Lang.Compiler.Ast.Attribute resultingNode)
		{

			if (EnterAttribute(node, ref resultingNode))
			{

				Switch(node.Arguments);

				Switch(node.NamedArguments);

				LeaveAttribute(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterAttribute(Boo.Lang.Compiler.Ast.Attribute node, ref Boo.Lang.Compiler.Ast.Attribute resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveAttribute(Boo.Lang.Compiler.Ast.Attribute node, ref Boo.Lang.Compiler.Ast.Attribute resultingNode)
		{
		}

		public virtual void OnStatementModifier(Boo.Lang.Compiler.Ast.StatementModifier node, ref Boo.Lang.Compiler.Ast.StatementModifier resultingNode)
		{

			if (EnterStatementModifier(node, ref resultingNode))
			{

				Expression currentConditionValue = node.Condition;
				if (null != currentConditionValue)
				{	
					Node resultingConditionValue;				
					currentConditionValue.Switch(this, out resultingConditionValue);					
					node.Condition = resultingConditionValue as Expression;
				}

				LeaveStatementModifier(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterStatementModifier(Boo.Lang.Compiler.Ast.StatementModifier node, ref Boo.Lang.Compiler.Ast.StatementModifier resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveStatementModifier(Boo.Lang.Compiler.Ast.StatementModifier node, ref Boo.Lang.Compiler.Ast.StatementModifier resultingNode)
		{
		}

		public virtual void OnBlock(Boo.Lang.Compiler.Ast.Block node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{

			if (EnterBlock(node, ref resultingNode))
			{

				StatementModifier currentModifierValue = node.Modifier;
				if (null != currentModifierValue)
				{	
					Node resultingModifierValue;				
					currentModifierValue.Switch(this, out resultingModifierValue);					
					node.Modifier = resultingModifierValue as StatementModifier;
				}

				Switch(node.Statements);

				LeaveBlock(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterBlock(Boo.Lang.Compiler.Ast.Block node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveBlock(Boo.Lang.Compiler.Ast.Block node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
		}

		public virtual void OnDeclarationStatement(Boo.Lang.Compiler.Ast.DeclarationStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{

			if (EnterDeclarationStatement(node, ref resultingNode))
			{

				StatementModifier currentModifierValue = node.Modifier;
				if (null != currentModifierValue)
				{	
					Node resultingModifierValue;				
					currentModifierValue.Switch(this, out resultingModifierValue);					
					node.Modifier = resultingModifierValue as StatementModifier;
				}

				Declaration currentDeclarationValue = node.Declaration;
				if (null != currentDeclarationValue)
				{	
					Node resultingDeclarationValue;				
					currentDeclarationValue.Switch(this, out resultingDeclarationValue);					
					node.Declaration = resultingDeclarationValue as Declaration;
				}

				Expression currentInitializerValue = node.Initializer;
				if (null != currentInitializerValue)
				{	
					Node resultingInitializerValue;				
					currentInitializerValue.Switch(this, out resultingInitializerValue);					
					node.Initializer = resultingInitializerValue as Expression;
				}

				LeaveDeclarationStatement(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterDeclarationStatement(Boo.Lang.Compiler.Ast.DeclarationStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveDeclarationStatement(Boo.Lang.Compiler.Ast.DeclarationStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
		}

		public virtual void OnAssertStatement(Boo.Lang.Compiler.Ast.AssertStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{

			if (EnterAssertStatement(node, ref resultingNode))
			{

				StatementModifier currentModifierValue = node.Modifier;
				if (null != currentModifierValue)
				{	
					Node resultingModifierValue;				
					currentModifierValue.Switch(this, out resultingModifierValue);					
					node.Modifier = resultingModifierValue as StatementModifier;
				}

				Expression currentConditionValue = node.Condition;
				if (null != currentConditionValue)
				{	
					Node resultingConditionValue;				
					currentConditionValue.Switch(this, out resultingConditionValue);					
					node.Condition = resultingConditionValue as Expression;
				}

				Expression currentMessageValue = node.Message;
				if (null != currentMessageValue)
				{	
					Node resultingMessageValue;				
					currentMessageValue.Switch(this, out resultingMessageValue);					
					node.Message = resultingMessageValue as Expression;
				}

				LeaveAssertStatement(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterAssertStatement(Boo.Lang.Compiler.Ast.AssertStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveAssertStatement(Boo.Lang.Compiler.Ast.AssertStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
		}

		public virtual void OnMacroStatement(Boo.Lang.Compiler.Ast.MacroStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{

			if (EnterMacroStatement(node, ref resultingNode))
			{

				StatementModifier currentModifierValue = node.Modifier;
				if (null != currentModifierValue)
				{	
					Node resultingModifierValue;				
					currentModifierValue.Switch(this, out resultingModifierValue);					
					node.Modifier = resultingModifierValue as StatementModifier;
				}

				Switch(node.Arguments);

				Block currentBlockValue = node.Block;
				if (null != currentBlockValue)
				{	
					Node resultingBlockValue;				
					currentBlockValue.Switch(this, out resultingBlockValue);					
					node.Block = resultingBlockValue as Block;
				}

				LeaveMacroStatement(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterMacroStatement(Boo.Lang.Compiler.Ast.MacroStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveMacroStatement(Boo.Lang.Compiler.Ast.MacroStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
		}

		public virtual void OnTryStatement(Boo.Lang.Compiler.Ast.TryStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{

			if (EnterTryStatement(node, ref resultingNode))
			{

				StatementModifier currentModifierValue = node.Modifier;
				if (null != currentModifierValue)
				{	
					Node resultingModifierValue;				
					currentModifierValue.Switch(this, out resultingModifierValue);					
					node.Modifier = resultingModifierValue as StatementModifier;
				}

				Block currentProtectedBlockValue = node.ProtectedBlock;
				if (null != currentProtectedBlockValue)
				{	
					Node resultingProtectedBlockValue;				
					currentProtectedBlockValue.Switch(this, out resultingProtectedBlockValue);					
					node.ProtectedBlock = resultingProtectedBlockValue as Block;
				}

				Switch(node.ExceptionHandlers);

				Block currentSuccessBlockValue = node.SuccessBlock;
				if (null != currentSuccessBlockValue)
				{	
					Node resultingSuccessBlockValue;				
					currentSuccessBlockValue.Switch(this, out resultingSuccessBlockValue);					
					node.SuccessBlock = resultingSuccessBlockValue as Block;
				}

				Block currentEnsureBlockValue = node.EnsureBlock;
				if (null != currentEnsureBlockValue)
				{	
					Node resultingEnsureBlockValue;				
					currentEnsureBlockValue.Switch(this, out resultingEnsureBlockValue);					
					node.EnsureBlock = resultingEnsureBlockValue as Block;
				}

				LeaveTryStatement(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterTryStatement(Boo.Lang.Compiler.Ast.TryStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveTryStatement(Boo.Lang.Compiler.Ast.TryStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
		}

		public virtual void OnExceptionHandler(Boo.Lang.Compiler.Ast.ExceptionHandler node, ref Boo.Lang.Compiler.Ast.ExceptionHandler resultingNode)
		{

			if (EnterExceptionHandler(node, ref resultingNode))
			{

				Declaration currentDeclarationValue = node.Declaration;
				if (null != currentDeclarationValue)
				{	
					Node resultingDeclarationValue;				
					currentDeclarationValue.Switch(this, out resultingDeclarationValue);					
					node.Declaration = resultingDeclarationValue as Declaration;
				}

				Block currentBlockValue = node.Block;
				if (null != currentBlockValue)
				{	
					Node resultingBlockValue;				
					currentBlockValue.Switch(this, out resultingBlockValue);					
					node.Block = resultingBlockValue as Block;
				}

				LeaveExceptionHandler(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterExceptionHandler(Boo.Lang.Compiler.Ast.ExceptionHandler node, ref Boo.Lang.Compiler.Ast.ExceptionHandler resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveExceptionHandler(Boo.Lang.Compiler.Ast.ExceptionHandler node, ref Boo.Lang.Compiler.Ast.ExceptionHandler resultingNode)
		{
		}

		public virtual void OnIfStatement(Boo.Lang.Compiler.Ast.IfStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{

			if (EnterIfStatement(node, ref resultingNode))
			{

				StatementModifier currentModifierValue = node.Modifier;
				if (null != currentModifierValue)
				{	
					Node resultingModifierValue;				
					currentModifierValue.Switch(this, out resultingModifierValue);					
					node.Modifier = resultingModifierValue as StatementModifier;
				}

				Expression currentConditionValue = node.Condition;
				if (null != currentConditionValue)
				{	
					Node resultingConditionValue;				
					currentConditionValue.Switch(this, out resultingConditionValue);					
					node.Condition = resultingConditionValue as Expression;
				}

				Block currentTrueBlockValue = node.TrueBlock;
				if (null != currentTrueBlockValue)
				{	
					Node resultingTrueBlockValue;				
					currentTrueBlockValue.Switch(this, out resultingTrueBlockValue);					
					node.TrueBlock = resultingTrueBlockValue as Block;
				}

				Block currentFalseBlockValue = node.FalseBlock;
				if (null != currentFalseBlockValue)
				{	
					Node resultingFalseBlockValue;				
					currentFalseBlockValue.Switch(this, out resultingFalseBlockValue);					
					node.FalseBlock = resultingFalseBlockValue as Block;
				}

				LeaveIfStatement(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterIfStatement(Boo.Lang.Compiler.Ast.IfStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveIfStatement(Boo.Lang.Compiler.Ast.IfStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
		}

		public virtual void OnUnlessStatement(Boo.Lang.Compiler.Ast.UnlessStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{

			if (EnterUnlessStatement(node, ref resultingNode))
			{

				StatementModifier currentModifierValue = node.Modifier;
				if (null != currentModifierValue)
				{	
					Node resultingModifierValue;				
					currentModifierValue.Switch(this, out resultingModifierValue);					
					node.Modifier = resultingModifierValue as StatementModifier;
				}

				Expression currentConditionValue = node.Condition;
				if (null != currentConditionValue)
				{	
					Node resultingConditionValue;				
					currentConditionValue.Switch(this, out resultingConditionValue);					
					node.Condition = resultingConditionValue as Expression;
				}

				Block currentBlockValue = node.Block;
				if (null != currentBlockValue)
				{	
					Node resultingBlockValue;				
					currentBlockValue.Switch(this, out resultingBlockValue);					
					node.Block = resultingBlockValue as Block;
				}

				LeaveUnlessStatement(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterUnlessStatement(Boo.Lang.Compiler.Ast.UnlessStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveUnlessStatement(Boo.Lang.Compiler.Ast.UnlessStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
		}

		public virtual void OnForStatement(Boo.Lang.Compiler.Ast.ForStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{

			if (EnterForStatement(node, ref resultingNode))
			{

				StatementModifier currentModifierValue = node.Modifier;
				if (null != currentModifierValue)
				{	
					Node resultingModifierValue;				
					currentModifierValue.Switch(this, out resultingModifierValue);					
					node.Modifier = resultingModifierValue as StatementModifier;
				}

				Switch(node.Declarations);

				Expression currentIteratorValue = node.Iterator;
				if (null != currentIteratorValue)
				{	
					Node resultingIteratorValue;				
					currentIteratorValue.Switch(this, out resultingIteratorValue);					
					node.Iterator = resultingIteratorValue as Expression;
				}

				Block currentBlockValue = node.Block;
				if (null != currentBlockValue)
				{	
					Node resultingBlockValue;				
					currentBlockValue.Switch(this, out resultingBlockValue);					
					node.Block = resultingBlockValue as Block;
				}

				LeaveForStatement(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterForStatement(Boo.Lang.Compiler.Ast.ForStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveForStatement(Boo.Lang.Compiler.Ast.ForStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
		}

		public virtual void OnWhileStatement(Boo.Lang.Compiler.Ast.WhileStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{

			if (EnterWhileStatement(node, ref resultingNode))
			{

				StatementModifier currentModifierValue = node.Modifier;
				if (null != currentModifierValue)
				{	
					Node resultingModifierValue;				
					currentModifierValue.Switch(this, out resultingModifierValue);					
					node.Modifier = resultingModifierValue as StatementModifier;
				}

				Expression currentConditionValue = node.Condition;
				if (null != currentConditionValue)
				{	
					Node resultingConditionValue;				
					currentConditionValue.Switch(this, out resultingConditionValue);					
					node.Condition = resultingConditionValue as Expression;
				}

				Block currentBlockValue = node.Block;
				if (null != currentBlockValue)
				{	
					Node resultingBlockValue;				
					currentBlockValue.Switch(this, out resultingBlockValue);					
					node.Block = resultingBlockValue as Block;
				}

				LeaveWhileStatement(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterWhileStatement(Boo.Lang.Compiler.Ast.WhileStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveWhileStatement(Boo.Lang.Compiler.Ast.WhileStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
		}

		public virtual void OnGivenStatement(Boo.Lang.Compiler.Ast.GivenStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{

			if (EnterGivenStatement(node, ref resultingNode))
			{

				StatementModifier currentModifierValue = node.Modifier;
				if (null != currentModifierValue)
				{	
					Node resultingModifierValue;				
					currentModifierValue.Switch(this, out resultingModifierValue);					
					node.Modifier = resultingModifierValue as StatementModifier;
				}

				Expression currentExpressionValue = node.Expression;
				if (null != currentExpressionValue)
				{	
					Node resultingExpressionValue;				
					currentExpressionValue.Switch(this, out resultingExpressionValue);					
					node.Expression = resultingExpressionValue as Expression;
				}

				Switch(node.WhenClauses);

				Block currentOtherwiseBlockValue = node.OtherwiseBlock;
				if (null != currentOtherwiseBlockValue)
				{	
					Node resultingOtherwiseBlockValue;				
					currentOtherwiseBlockValue.Switch(this, out resultingOtherwiseBlockValue);					
					node.OtherwiseBlock = resultingOtherwiseBlockValue as Block;
				}

				LeaveGivenStatement(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterGivenStatement(Boo.Lang.Compiler.Ast.GivenStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveGivenStatement(Boo.Lang.Compiler.Ast.GivenStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
		}

		public virtual void OnWhenClause(Boo.Lang.Compiler.Ast.WhenClause node, ref Boo.Lang.Compiler.Ast.WhenClause resultingNode)
		{

			if (EnterWhenClause(node, ref resultingNode))
			{

				Expression currentConditionValue = node.Condition;
				if (null != currentConditionValue)
				{	
					Node resultingConditionValue;				
					currentConditionValue.Switch(this, out resultingConditionValue);					
					node.Condition = resultingConditionValue as Expression;
				}

				Block currentBlockValue = node.Block;
				if (null != currentBlockValue)
				{	
					Node resultingBlockValue;				
					currentBlockValue.Switch(this, out resultingBlockValue);					
					node.Block = resultingBlockValue as Block;
				}

				LeaveWhenClause(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterWhenClause(Boo.Lang.Compiler.Ast.WhenClause node, ref Boo.Lang.Compiler.Ast.WhenClause resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveWhenClause(Boo.Lang.Compiler.Ast.WhenClause node, ref Boo.Lang.Compiler.Ast.WhenClause resultingNode)
		{
		}

		public virtual void OnBreakStatement(Boo.Lang.Compiler.Ast.BreakStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{

			if (EnterBreakStatement(node, ref resultingNode))
			{

				StatementModifier currentModifierValue = node.Modifier;
				if (null != currentModifierValue)
				{	
					Node resultingModifierValue;				
					currentModifierValue.Switch(this, out resultingModifierValue);					
					node.Modifier = resultingModifierValue as StatementModifier;
				}

				LeaveBreakStatement(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterBreakStatement(Boo.Lang.Compiler.Ast.BreakStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveBreakStatement(Boo.Lang.Compiler.Ast.BreakStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
		}

		public virtual void OnContinueStatement(Boo.Lang.Compiler.Ast.ContinueStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{

			if (EnterContinueStatement(node, ref resultingNode))
			{

				StatementModifier currentModifierValue = node.Modifier;
				if (null != currentModifierValue)
				{	
					Node resultingModifierValue;				
					currentModifierValue.Switch(this, out resultingModifierValue);					
					node.Modifier = resultingModifierValue as StatementModifier;
				}

				LeaveContinueStatement(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterContinueStatement(Boo.Lang.Compiler.Ast.ContinueStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveContinueStatement(Boo.Lang.Compiler.Ast.ContinueStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
		}

		public virtual void OnRetryStatement(Boo.Lang.Compiler.Ast.RetryStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{

			if (EnterRetryStatement(node, ref resultingNode))
			{

				StatementModifier currentModifierValue = node.Modifier;
				if (null != currentModifierValue)
				{	
					Node resultingModifierValue;				
					currentModifierValue.Switch(this, out resultingModifierValue);					
					node.Modifier = resultingModifierValue as StatementModifier;
				}

				LeaveRetryStatement(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterRetryStatement(Boo.Lang.Compiler.Ast.RetryStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveRetryStatement(Boo.Lang.Compiler.Ast.RetryStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
		}

		public virtual void OnReturnStatement(Boo.Lang.Compiler.Ast.ReturnStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{

			if (EnterReturnStatement(node, ref resultingNode))
			{

				StatementModifier currentModifierValue = node.Modifier;
				if (null != currentModifierValue)
				{	
					Node resultingModifierValue;				
					currentModifierValue.Switch(this, out resultingModifierValue);					
					node.Modifier = resultingModifierValue as StatementModifier;
				}

				Expression currentExpressionValue = node.Expression;
				if (null != currentExpressionValue)
				{	
					Node resultingExpressionValue;				
					currentExpressionValue.Switch(this, out resultingExpressionValue);					
					node.Expression = resultingExpressionValue as Expression;
				}

				LeaveReturnStatement(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterReturnStatement(Boo.Lang.Compiler.Ast.ReturnStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveReturnStatement(Boo.Lang.Compiler.Ast.ReturnStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
		}

		public virtual void OnYieldStatement(Boo.Lang.Compiler.Ast.YieldStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{

			if (EnterYieldStatement(node, ref resultingNode))
			{

				StatementModifier currentModifierValue = node.Modifier;
				if (null != currentModifierValue)
				{	
					Node resultingModifierValue;				
					currentModifierValue.Switch(this, out resultingModifierValue);					
					node.Modifier = resultingModifierValue as StatementModifier;
				}

				Expression currentExpressionValue = node.Expression;
				if (null != currentExpressionValue)
				{	
					Node resultingExpressionValue;				
					currentExpressionValue.Switch(this, out resultingExpressionValue);					
					node.Expression = resultingExpressionValue as Expression;
				}

				LeaveYieldStatement(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterYieldStatement(Boo.Lang.Compiler.Ast.YieldStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveYieldStatement(Boo.Lang.Compiler.Ast.YieldStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
		}

		public virtual void OnRaiseStatement(Boo.Lang.Compiler.Ast.RaiseStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{

			if (EnterRaiseStatement(node, ref resultingNode))
			{

				StatementModifier currentModifierValue = node.Modifier;
				if (null != currentModifierValue)
				{	
					Node resultingModifierValue;				
					currentModifierValue.Switch(this, out resultingModifierValue);					
					node.Modifier = resultingModifierValue as StatementModifier;
				}

				Expression currentExceptionValue = node.Exception;
				if (null != currentExceptionValue)
				{	
					Node resultingExceptionValue;				
					currentExceptionValue.Switch(this, out resultingExceptionValue);					
					node.Exception = resultingExceptionValue as Expression;
				}

				LeaveRaiseStatement(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterRaiseStatement(Boo.Lang.Compiler.Ast.RaiseStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveRaiseStatement(Boo.Lang.Compiler.Ast.RaiseStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
		}

		public virtual void OnUnpackStatement(Boo.Lang.Compiler.Ast.UnpackStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{

			if (EnterUnpackStatement(node, ref resultingNode))
			{

				StatementModifier currentModifierValue = node.Modifier;
				if (null != currentModifierValue)
				{	
					Node resultingModifierValue;				
					currentModifierValue.Switch(this, out resultingModifierValue);					
					node.Modifier = resultingModifierValue as StatementModifier;
				}

				Switch(node.Declarations);

				Expression currentExpressionValue = node.Expression;
				if (null != currentExpressionValue)
				{	
					Node resultingExpressionValue;				
					currentExpressionValue.Switch(this, out resultingExpressionValue);					
					node.Expression = resultingExpressionValue as Expression;
				}

				LeaveUnpackStatement(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterUnpackStatement(Boo.Lang.Compiler.Ast.UnpackStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveUnpackStatement(Boo.Lang.Compiler.Ast.UnpackStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
		}

		public virtual void OnExpressionStatement(Boo.Lang.Compiler.Ast.ExpressionStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{

			if (EnterExpressionStatement(node, ref resultingNode))
			{

				StatementModifier currentModifierValue = node.Modifier;
				if (null != currentModifierValue)
				{	
					Node resultingModifierValue;				
					currentModifierValue.Switch(this, out resultingModifierValue);					
					node.Modifier = resultingModifierValue as StatementModifier;
				}

				Expression currentExpressionValue = node.Expression;
				if (null != currentExpressionValue)
				{	
					Node resultingExpressionValue;				
					currentExpressionValue.Switch(this, out resultingExpressionValue);					
					node.Expression = resultingExpressionValue as Expression;
				}

				LeaveExpressionStatement(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterExpressionStatement(Boo.Lang.Compiler.Ast.ExpressionStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveExpressionStatement(Boo.Lang.Compiler.Ast.ExpressionStatement node, ref Boo.Lang.Compiler.Ast.Statement resultingNode)
		{
		}

		public virtual void OnOmittedExpression(Boo.Lang.Compiler.Ast.OmittedExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{

		}

		public virtual void OnExpressionPair(Boo.Lang.Compiler.Ast.ExpressionPair node, ref Boo.Lang.Compiler.Ast.ExpressionPair resultingNode)
		{

			if (EnterExpressionPair(node, ref resultingNode))
			{

				Expression currentFirstValue = node.First;
				if (null != currentFirstValue)
				{	
					Node resultingFirstValue;				
					currentFirstValue.Switch(this, out resultingFirstValue);					
					node.First = resultingFirstValue as Expression;
				}

				Expression currentSecondValue = node.Second;
				if (null != currentSecondValue)
				{	
					Node resultingSecondValue;				
					currentSecondValue.Switch(this, out resultingSecondValue);					
					node.Second = resultingSecondValue as Expression;
				}

				LeaveExpressionPair(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterExpressionPair(Boo.Lang.Compiler.Ast.ExpressionPair node, ref Boo.Lang.Compiler.Ast.ExpressionPair resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveExpressionPair(Boo.Lang.Compiler.Ast.ExpressionPair node, ref Boo.Lang.Compiler.Ast.ExpressionPair resultingNode)
		{
		}

		public virtual void OnMethodInvocationExpression(Boo.Lang.Compiler.Ast.MethodInvocationExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{

			if (EnterMethodInvocationExpression(node, ref resultingNode))
			{

				Expression currentTargetValue = node.Target;
				if (null != currentTargetValue)
				{	
					Node resultingTargetValue;				
					currentTargetValue.Switch(this, out resultingTargetValue);					
					node.Target = resultingTargetValue as Expression;
				}

				Switch(node.Arguments);

				Switch(node.NamedArguments);

				LeaveMethodInvocationExpression(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterMethodInvocationExpression(Boo.Lang.Compiler.Ast.MethodInvocationExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveMethodInvocationExpression(Boo.Lang.Compiler.Ast.MethodInvocationExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{
		}

		public virtual void OnUnaryExpression(Boo.Lang.Compiler.Ast.UnaryExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{

			if (EnterUnaryExpression(node, ref resultingNode))
			{

				Expression currentOperandValue = node.Operand;
				if (null != currentOperandValue)
				{	
					Node resultingOperandValue;				
					currentOperandValue.Switch(this, out resultingOperandValue);					
					node.Operand = resultingOperandValue as Expression;
				}

				LeaveUnaryExpression(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterUnaryExpression(Boo.Lang.Compiler.Ast.UnaryExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveUnaryExpression(Boo.Lang.Compiler.Ast.UnaryExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{
		}

		public virtual void OnBinaryExpression(Boo.Lang.Compiler.Ast.BinaryExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{

			if (EnterBinaryExpression(node, ref resultingNode))
			{

				Expression currentLeftValue = node.Left;
				if (null != currentLeftValue)
				{	
					Node resultingLeftValue;				
					currentLeftValue.Switch(this, out resultingLeftValue);					
					node.Left = resultingLeftValue as Expression;
				}

				Expression currentRightValue = node.Right;
				if (null != currentRightValue)
				{	
					Node resultingRightValue;				
					currentRightValue.Switch(this, out resultingRightValue);					
					node.Right = resultingRightValue as Expression;
				}

				LeaveBinaryExpression(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterBinaryExpression(Boo.Lang.Compiler.Ast.BinaryExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveBinaryExpression(Boo.Lang.Compiler.Ast.BinaryExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{
		}

		public virtual void OnTernaryExpression(Boo.Lang.Compiler.Ast.TernaryExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{

			if (EnterTernaryExpression(node, ref resultingNode))
			{

				Expression currentConditionValue = node.Condition;
				if (null != currentConditionValue)
				{	
					Node resultingConditionValue;				
					currentConditionValue.Switch(this, out resultingConditionValue);					
					node.Condition = resultingConditionValue as Expression;
				}

				Expression currentTrueExpressionValue = node.TrueExpression;
				if (null != currentTrueExpressionValue)
				{	
					Node resultingTrueExpressionValue;				
					currentTrueExpressionValue.Switch(this, out resultingTrueExpressionValue);					
					node.TrueExpression = resultingTrueExpressionValue as Expression;
				}

				Expression currentFalseExpressionValue = node.FalseExpression;
				if (null != currentFalseExpressionValue)
				{	
					Node resultingFalseExpressionValue;				
					currentFalseExpressionValue.Switch(this, out resultingFalseExpressionValue);					
					node.FalseExpression = resultingFalseExpressionValue as Expression;
				}

				LeaveTernaryExpression(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterTernaryExpression(Boo.Lang.Compiler.Ast.TernaryExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveTernaryExpression(Boo.Lang.Compiler.Ast.TernaryExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{
		}

		public virtual void OnReferenceExpression(Boo.Lang.Compiler.Ast.ReferenceExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{

		}

		public virtual void OnMemberReferenceExpression(Boo.Lang.Compiler.Ast.MemberReferenceExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{

			if (EnterMemberReferenceExpression(node, ref resultingNode))
			{

				Expression currentTargetValue = node.Target;
				if (null != currentTargetValue)
				{	
					Node resultingTargetValue;				
					currentTargetValue.Switch(this, out resultingTargetValue);					
					node.Target = resultingTargetValue as Expression;
				}

				LeaveMemberReferenceExpression(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterMemberReferenceExpression(Boo.Lang.Compiler.Ast.MemberReferenceExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveMemberReferenceExpression(Boo.Lang.Compiler.Ast.MemberReferenceExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{
		}

		public virtual void OnStringLiteralExpression(Boo.Lang.Compiler.Ast.StringLiteralExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{

		}

		public virtual void OnTimeSpanLiteralExpression(Boo.Lang.Compiler.Ast.TimeSpanLiteralExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{

		}

		public virtual void OnIntegerLiteralExpression(Boo.Lang.Compiler.Ast.IntegerLiteralExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{

		}

		public virtual void OnDoubleLiteralExpression(Boo.Lang.Compiler.Ast.DoubleLiteralExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{

		}

		public virtual void OnNullLiteralExpression(Boo.Lang.Compiler.Ast.NullLiteralExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{

		}

		public virtual void OnSelfLiteralExpression(Boo.Lang.Compiler.Ast.SelfLiteralExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{

		}

		public virtual void OnSuperLiteralExpression(Boo.Lang.Compiler.Ast.SuperLiteralExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{

		}

		public virtual void OnBoolLiteralExpression(Boo.Lang.Compiler.Ast.BoolLiteralExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{

		}

		public virtual void OnRELiteralExpression(Boo.Lang.Compiler.Ast.RELiteralExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{

		}

		public virtual void OnStringFormattingExpression(Boo.Lang.Compiler.Ast.StringFormattingExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{

			if (EnterStringFormattingExpression(node, ref resultingNode))
			{

				Switch(node.Arguments);

				LeaveStringFormattingExpression(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterStringFormattingExpression(Boo.Lang.Compiler.Ast.StringFormattingExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveStringFormattingExpression(Boo.Lang.Compiler.Ast.StringFormattingExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{
		}

		public virtual void OnHashLiteralExpression(Boo.Lang.Compiler.Ast.HashLiteralExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{

			if (EnterHashLiteralExpression(node, ref resultingNode))
			{

				Switch(node.Items);

				LeaveHashLiteralExpression(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterHashLiteralExpression(Boo.Lang.Compiler.Ast.HashLiteralExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveHashLiteralExpression(Boo.Lang.Compiler.Ast.HashLiteralExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{
		}

		public virtual void OnListLiteralExpression(Boo.Lang.Compiler.Ast.ListLiteralExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{

			if (EnterListLiteralExpression(node, ref resultingNode))
			{

				Switch(node.Items);

				LeaveListLiteralExpression(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterListLiteralExpression(Boo.Lang.Compiler.Ast.ListLiteralExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveListLiteralExpression(Boo.Lang.Compiler.Ast.ListLiteralExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{
		}

		public virtual void OnTupleLiteralExpression(Boo.Lang.Compiler.Ast.TupleLiteralExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{

			if (EnterTupleLiteralExpression(node, ref resultingNode))
			{

				Switch(node.Items);

				LeaveTupleLiteralExpression(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterTupleLiteralExpression(Boo.Lang.Compiler.Ast.TupleLiteralExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveTupleLiteralExpression(Boo.Lang.Compiler.Ast.TupleLiteralExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{
		}

		public virtual void OnIteratorExpression(Boo.Lang.Compiler.Ast.IteratorExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{

			if (EnterIteratorExpression(node, ref resultingNode))
			{

				Expression currentExpressionValue = node.Expression;
				if (null != currentExpressionValue)
				{	
					Node resultingExpressionValue;				
					currentExpressionValue.Switch(this, out resultingExpressionValue);					
					node.Expression = resultingExpressionValue as Expression;
				}

				Switch(node.Declarations);

				Expression currentIteratorValue = node.Iterator;
				if (null != currentIteratorValue)
				{	
					Node resultingIteratorValue;				
					currentIteratorValue.Switch(this, out resultingIteratorValue);					
					node.Iterator = resultingIteratorValue as Expression;
				}

				StatementModifier currentFilterValue = node.Filter;
				if (null != currentFilterValue)
				{	
					Node resultingFilterValue;				
					currentFilterValue.Switch(this, out resultingFilterValue);					
					node.Filter = resultingFilterValue as StatementModifier;
				}

				LeaveIteratorExpression(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterIteratorExpression(Boo.Lang.Compiler.Ast.IteratorExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveIteratorExpression(Boo.Lang.Compiler.Ast.IteratorExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{
		}

		public virtual void OnSlicingExpression(Boo.Lang.Compiler.Ast.SlicingExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{

			if (EnterSlicingExpression(node, ref resultingNode))
			{

				Expression currentTargetValue = node.Target;
				if (null != currentTargetValue)
				{	
					Node resultingTargetValue;				
					currentTargetValue.Switch(this, out resultingTargetValue);					
					node.Target = resultingTargetValue as Expression;
				}

				Expression currentBeginValue = node.Begin;
				if (null != currentBeginValue)
				{	
					Node resultingBeginValue;				
					currentBeginValue.Switch(this, out resultingBeginValue);					
					node.Begin = resultingBeginValue as Expression;
				}

				Expression currentEndValue = node.End;
				if (null != currentEndValue)
				{	
					Node resultingEndValue;				
					currentEndValue.Switch(this, out resultingEndValue);					
					node.End = resultingEndValue as Expression;
				}

				Expression currentStepValue = node.Step;
				if (null != currentStepValue)
				{	
					Node resultingStepValue;				
					currentStepValue.Switch(this, out resultingStepValue);					
					node.Step = resultingStepValue as Expression;
				}

				LeaveSlicingExpression(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterSlicingExpression(Boo.Lang.Compiler.Ast.SlicingExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveSlicingExpression(Boo.Lang.Compiler.Ast.SlicingExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{
		}

		public virtual void OnAsExpression(Boo.Lang.Compiler.Ast.AsExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{

			if (EnterAsExpression(node, ref resultingNode))
			{

				Expression currentTargetValue = node.Target;
				if (null != currentTargetValue)
				{	
					Node resultingTargetValue;				
					currentTargetValue.Switch(this, out resultingTargetValue);					
					node.Target = resultingTargetValue as Expression;
				}

				TypeReference currentTypeValue = node.Type;
				if (null != currentTypeValue)
				{	
					Node resultingTypeValue;				
					currentTypeValue.Switch(this, out resultingTypeValue);					
					node.Type = resultingTypeValue as TypeReference;
				}

				LeaveAsExpression(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterAsExpression(Boo.Lang.Compiler.Ast.AsExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveAsExpression(Boo.Lang.Compiler.Ast.AsExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{
		}

		public virtual void OnCastExpression(Boo.Lang.Compiler.Ast.CastExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{

			if (EnterCastExpression(node, ref resultingNode))
			{

				TypeReference currentTypeValue = node.Type;
				if (null != currentTypeValue)
				{	
					Node resultingTypeValue;				
					currentTypeValue.Switch(this, out resultingTypeValue);					
					node.Type = resultingTypeValue as TypeReference;
				}

				Expression currentTargetValue = node.Target;
				if (null != currentTargetValue)
				{	
					Node resultingTargetValue;				
					currentTargetValue.Switch(this, out resultingTargetValue);					
					node.Target = resultingTargetValue as Expression;
				}

				LeaveCastExpression(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterCastExpression(Boo.Lang.Compiler.Ast.CastExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveCastExpression(Boo.Lang.Compiler.Ast.CastExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{
		}

		public virtual void OnTypeofExpression(Boo.Lang.Compiler.Ast.TypeofExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{

			if (EnterTypeofExpression(node, ref resultingNode))
			{

				TypeReference currentTypeValue = node.Type;
				if (null != currentTypeValue)
				{	
					Node resultingTypeValue;				
					currentTypeValue.Switch(this, out resultingTypeValue);					
					node.Type = resultingTypeValue as TypeReference;
				}

				LeaveTypeofExpression(node, ref resultingNode);
			}

		}
				
		public virtual bool EnterTypeofExpression(Boo.Lang.Compiler.Ast.TypeofExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{
			return true;
		}
		
		public virtual void LeaveTypeofExpression(Boo.Lang.Compiler.Ast.TypeofExpression node, ref Boo.Lang.Compiler.Ast.Expression resultingNode)
		{
		}

		public bool Switch(Node node, out Node resultingNode)
		{			
			if (null != node)
			{			
				node.Switch(this, out resultingNode);
				return true;
			}
			resultingNode = node;
			return false;
		}
		
		public Node SwitchNode(Node node)
		{
			if (null != node)
			{
				Node resultingNode;
				node.Switch(this, out resultingNode);
				return resultingNode;
			}
			return null;
		}
		
		public Node Switch(Node node)
		{
			return SwitchNode(node);
		}
		
		public Expression Switch(Expression node)
		{
			return (Expression)SwitchNode(node);
		}
		
		public Statement Switch(Statement node)
		{
			return (Statement)SwitchNode(node);
		}
		
		public bool Switch(NodeCollection collection)
		{
			if (null != collection)
			{
				int removed = 0;
				
				Node[] nodes = collection.ToArray();
				for (int i=0; i<nodes.Length; ++i)
				{
					Node resultingNode;
					Node currentNode = nodes[i];
					currentNode.Switch(this, out resultingNode);
					if (currentNode != resultingNode)
					{
						int actualIndex = i-removed;
						if (null == resultingNode)
						{
							collection.RemoveAt(actualIndex);
						}
						else
						{
							collection.ReplaceAt(actualIndex, resultingNode);
						}
					}
				}
				return true;
			}
			return false;
		}
	}
}

