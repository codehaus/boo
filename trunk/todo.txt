* a lista de tarefas migrou para http://bamboo.is-a-geek.org:8080/boo/wiki/TodoList

Geração de Código
=================

Milestone 1 (hello.boo)
-----------------------

done * bultins
done * local variables
done * expression interpolation (string formatting)
 
Milestone 2 (debug)
-------------------

done * line numbers na vers�o de depura��o
done * depurar com o mscordbg

Milestone 3 (helloforms.boo - using, métodos estáticos, criação de objetos)
---------------------------------------------------------------------------
done * using XXX from XXX
done * criar objeto (ConstructorBinding)
done * membros de instancia (f.Show())
done * argumentos nomeados na criação de objetos
done * membros estáticos Application.Run()
done * resolução de métodos por argumentos de tipo compatível
done * simplificar código:
	done * InternalTypeBinding e ExternalTypeBinding implements INameSpace: unificar codigo;
	done * o mesmo para InternalMethodBinding;
done * propriedades simples (f.Controls)

Milestone 3.1 (grep.boo)
----------------------

done * definição de métodos do módulo
done * chamada de métodos do módulo
done * checagem de parametros estrita nas invocaçoes de método
done * array unpacking
done * for item in array
done * for index, item in enumerate(array)
done * melhor mensagem de erro para array unpacking (checar length do array antes de acessá-lo 
e emitir exception "Unpack list of wrong size")
done * Quando o argumento do For ou Unpack for do tipo System.Object, não fazer simplesmente cast
mas invocar RuntimeServices.GetEnumerable(object) que tenta encontrar a melhor versão de 
um enumerável para o objeto passado e, no caso de falha, exibe mensagem de erro mais adequada
done * RuntimeServices.GetEnumerable(object) deve suportar StreamReader
done * resolução de métodos
done * downcast (peverify grep)
* native regular expression support:
	* re expression /foo/
	done * match operator ~=
done * if stmt modifier

Milestone 3.3 (replace.boo)
---------------------------
done * using Type (using Boo.IO.TextFile)
done * if string compare

Milestone 3.4 (rgrep.boo)
-------------------------
done * recursive functions
done * namespace resolution for MemberReferenceExpression
done * using namespace as

Milestone 3.5
-------------
done * IAstTransformer: uma maneira mais integrada de alterar os nós da AST em uma visita
DepthFirst, a interface é parecida com IAstSwitcher com a diferença de que cada método,
tem um valor de entrada e DE SAÍDA que é o novo nó a ser colocado no lugar do nó visitado:
	void OnModule(Module module, ref Module newModule);
	void OnIfStatement(IfStatement statement, ref Statement newStatement)
	void OnBinaryExpression(BinaryExpression expression, ref Expression newExpression)
done * matar Boo.Util.ISwitch/ISwitcher, eles não agregam valor algum no momento
done * quebrar AbstractCompilerStep em AbstractAstSwitcherStep extends AbstractCompilerStep
done * criar AbstractAstTransformerStep extends AbstractCompilerStep
done * unit tests para o compilador/interpretador
	done * criar uma pasta onde cada arquivo .boo é um testcase com um equivalente .out
	que contém a saída esperada
	done * o teste executa todos os passos da compilação normal e verifica o arquivo final com peverify
* mover todos as constantes de tipo de BindingManager para Types
* LeaveDeclarationStatement retorna um ExpressionStatement(BinaryExpression()) de assignment
e declara a variável
* remover alguns dos EmitCastIfNeeded do EmitAssemblyStep e move-los para o SemanticStep que deverá
criar CastExpression sempre que necessário
* AstAttribute vira IAstAttribute que implementa ICompilerStep
* Criar AbstractAstAttribute extends AbstractCompilerStep
* melhor tratamento de TypeReferences no parser, o tipo TypeReference desaparece
e passa a ser utilizado ReferenceExpression em seu lugar (para utilizar a resolução padrão de membros, etc)

Milestone 3.6 (revisão)
-----------------------
done * boxing (print e StringFormatting)
* ? for deve criar um try { } finally { RuntimeServices.DisposeEnumerator(iterator); }
* transformação de acesso de propriedade em invocaçao de método passa para SemanticStep

Milestone 3.8
-------------
* raise
* statement modifiers:
	* unless
	* while
	* until
* try/catch/ensure
	
Milestone 4 (delegate support)
------------------------------

* automatic delegation instance creation
* automatic delegation interface adaptation

Milestone 4.3 (otimizações)
---------------------------
* compilador deve entender o atributo [EnumeratorItemType(typeof(string))] para TextFile e StreamReaderEnumerator
e declarar os tipos de acordo
* criar ModuleBinding e unificar com ModuleNamespace;

Milestone 5
-----------

* classes
* declara��o de campos
* declara��o de propriedades
* defini��o de m�todos
* expressões simples com inteiros
* concatenação de strings
* concatenação de strings com inteiros
* classes devem ser serializ�veis
* cria��o de objetos (classes internas)
* chamada de m�todos est�ticos (classes internas)
* chamada de m�todos instance
* null expression
* assert statement
* tuples (arrays) - operador v�rgula => a = 3, 5
* tuple unpacking - a, b  = 3, 5
* tuple indexing (a[0] = 1)
done * for item in tuple
* property access
* property assignment
* list creation [1, 2, 3]
* list indexing
done * bool (true, false)
* operadores de convers�o (operator bool, operator string, etc)

Milestone 6
-----------

* enum
* interface
* property

Otimiza��es
-----------
* tail call prefix para funçoes recursivas com a ScanDirectories do rgrep.boo

* os métodos com yield e métodos que retornam iterators como enumerate devem
marcar o tipo retornado por IEnumerator.Current de forma que o compilador
possa otimizar a utilizaçao de tais itens (no caso do enumerate, o compilador
saberia que sempre estaria lidando com um array e poderia gerar um unpacking
otimizado, etc);
* const expression unfolding
* proper tail recursion (fatorial)
* for item in array/tuple => traduzir indexaçãoo direta do array com checagem de
bounds, o JIT é capaz de detectar esses patterns e otimizar o c�digo de acordo
